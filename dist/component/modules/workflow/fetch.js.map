{"version":3,"file":"fetch.js","sourceRoot":"","sources":["../../../../src/component/modules/workflow/fetch.ts"],"names":[],"mappings":"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","sourcesContent":["import Data from '../data'\nimport Elements from '../elements'\nimport Direction from '../direction'\n\nclass Fetch {\n\n  static pendingTop = false;\n  static pendingBottom = false;\n\n  static run(direction) {\n    if (direction === Direction.top) {\n      return self.runTop();\n    }\n    if (direction === Direction.bottom) {\n      return self.runBottom();\n    }\n  }\n\n  static shouldLoadBottom() {\n    if (self.pendingBottom) {\n      return false;\n    }\n    const lastItem = Data.getLastVisibleItem();\n    if (!lastItem) {\n      return true;\n    }\n    const viewportBottom = Elements.viewport.getBoundingClientRect().bottom;\n    const lastElementBottom = lastItem.element.getBoundingClientRect().bottom;\n    return lastElementBottom <= viewportBottom;\n  }\n\n  static shouldLoadTop() {\n    if (self.pendingTop) {\n      return false;\n    }\n    const firstItem = Data.getFirstVisibleItem();\n    if (!firstItem) {\n      return true;\n    }\n    const viewportTop = Elements.viewport.getBoundingClientRect().top;\n    const firstElementTop = firstItem.element.getBoundingClientRect().top;\n    return firstElementTop >= viewportTop;\n  }\n\n  static runTop() {\n    return new Promise((resolve, reject) => {\n      if (self.shouldLoadTop()) {\n        self.pendingTop = true;\n        const start = (Data.items.length ?\n          Data.items[0].$index :\n          (Data.lastIndex !== null ? Data.lastIndex : Data.startIndex))\n           - Data.bufferSize;\n        Data.source.get(start, Data.bufferSize).subscribe((result) => {\n          self.pendingTop = false;\n          Data.bof = result.length !== Data.bufferSize;\n\n          const items = result.map((item, index) => ({\n            $index: start + index,\n            scope: item,\n            invisible: true\n          }));\n          Data.items = [...items, ...Data.items];\n\n          resolve(items);\n        });\n      }\n      else {\n        reject();\n      }\n    });\n  }\n\n  static runBottom() {\n    return new Promise((resolve, reject) => {\n      if (self.shouldLoadBottom()) {\n        self.pendingBottom = true;\n        const start = Data.items.length ?\n          Data.items[Data.items.length - 1].$index + 1 :\n          (Data.lastIndex !== null ? Data.lastIndex + 1 : Data.startIndex);\n\n        Data.source.get(start, Data.bufferSize).subscribe((result) => {\n          self.pendingBottom = false;\n          Data.eof = result.length !== Data.bufferSize;\n\n          const items = result.map((item, index) => ({\n            $index: start + index,\n            scope: item,\n            invisible: true\n          }));\n          Data.items = [...Data.items, ...items];\n\n          resolve(items);\n        });\n      }\n      else {\n        reject();\n      }\n    });\n  }\n\n}\n\nconst self = Fetch;\nexport default Fetch"]}